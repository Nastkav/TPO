
 
Input DataMR
1
MR
2
P1 P2 P3MR
3
 MR
4
P5 P6P4 P8 P9P7 P12P10MR
5
P14 P15P13MR
6
P11P17 P18P16Single-nodeDistributedThe partition is small enough to be solved in asingle node. Results written to final output in HDFS.The partition will need to be further re-partitionedin additional MapReduce rounds. Intermediatedata is written to HDFS.
Figure 4: Example of the MapReduce rounds and partitions generated by MR-SimJoin.
 p
,
 p
1 and
 p
2 are pivot indices.
 uAttr
 ensures unique directory names. Thetype of partition being stored in a directory can be identiﬁed from the directoryname (use of B or W).Each iteration of the while loop (lines 3 to 22) corresponds to one round andexecutes a MapReduce job. In each round, the initial input data or a previouslygenerated partition is repartitioned. If a newly generated partition is smallenough to be processed in a single node, the Similarity Join links are obtainedrunning a single-node Similarity Join algorithm. In our implementation we useQuickjoin [16]. Larger partitions are stored as intermediate data for furtherprocessing.For each round, the main routine sets the values of the job input directory(lines 4 to 8) and randomly selects
 numPivots
 pivots from this directory (line12). Then the routine executes a base partition MapReduce job (line 14) ora window-pair partition MapReduce job (line 16) based on the type of the jobinput directory. The routine
 MR Job
 sets up a MapReduce job that will use theprovided
 map
,
 reduce 
,
 partition 
 and
 compare 
 functions. The
 partition 
 functionwill be used to replace the default
 partition 
 function. The
 compare 
 functionwill be used to replace the default
 sortCompare 
 and
 groupCompare 
 functions.
MR Job
 also makes sure that the provided atomic parameters, i.e.,
 outDir
,
numPiv
,
 eps
 and
 memT 
, are available at every node that will be used in theMapReduce job and that the
 pivots
 are available at each node that will execute
map
 tasks.If a round is processing a previously generated partition, after the MapRe-duce job ﬁnishes, the main routine renames the job input directory to relocateit under the processed directories (line 20).Fig. 4 shows an example of the multiple rounds that are executed by the9

 
Algorithm 2
 Map base 
()
Input:
 (
k
1
,v
1).
 k
1 =
 id,v
1 = (
id,elem
)
Output:
 list(
k
2
,v
2).
 k
2 = (
 part,win
),
 v
2 = (
id,elem,part
)
1:
 p
 ←
 GetClosestPivotIndx 
(
elem,pivots
)
2:
 output ((
 p,
−
1)
,
(
id,elem,
−
1))
3:
 for
 i
 = 0
 →
 numPiv
−
1
 do
4:
 if 
 i
 ̸
=
 p
 then
5:
 if 
 (
dist 
(
elem,pivots
[
i
])
−
dist 
(
elem,pivots
[
 p
]))
/
2
 ≤
 eps
 then
6:
 output ((
 p,i
)
,
(
id,elem,p
))
7:
 end if 
8:
 end if 
9:
 end for
Base Partitions Window-pair PartitionP
0
 P
1
P0 P1
 
(id
3
, (id
3
,elem
3
)) (id
4
, (id
4
,elem
4
))(id
6
, (id
6
,elem
6
))(id
5
, (id
5
,elem
5
))(id
1
, (id
1
,elem
1
))(id
2
, (id
2
,elem
2
))((
P
0
,-1), (id
1
,elem
1
))((
P
1
,-1), (id
2
,elem
2
))((
P
0
,-1), (id
3
,elem
3
)) ((
P
1
,-1), (id
4
,elem
4
))((
P
1
,-1), (id
6
,elem
6
))((
P
0
,-1), (id
5
,elem
5
))((
P
0
,
P
1
),(id
5
,elem
5
,
P
0
)) ((
P
1
,
P
0
),(id
6
,elem
6
,
P
1
))
P0_P1T
Figure 5: Example of the Map function for a base round.main routine. Each node in the tree with name
 MR
N 
 represents a MapReduce job. This ﬁgure also shows the partitions generated by each job. Light graypartitions are small partitions that are processed running the single-node Sim-ilarity Join routine. Dark gray partitions are partitions that require additionalrepartitioning. A sample sequence of rounds can be:
 MR
1
,
 MR
2
,
 MR
3
,
 MR
4
,
MR
5
 and
 MR
6
. The original input data is always processed in the ﬁrst round.Since the links of any partition can be obtained independently, the routine willgenerate a correct result independently of the order of rounds.
3.2.2 Base Partition Round
A base partition round processes the initial input data or a base partition previ-ously generated by a base partition round. Each base partition round executesa MapReduce job initialized by the main routine as described in Section 3.2.1.The goal of a base partition MapReduce job is to partition its input data and10

 
Algorithm 3
 Partition base 
()
Input:
 k
2.
 k
2 = (
 part,win
)
Output:
 k
2’s partition number
1:
 if 
 win
 =
 −
1
 then
 // base partition
2:
 partition
 ←
 (
 part
×
C 
1) mod
 NUMPARTITIONS 
3:
 else
 // window-pair partition
4:
 minV al
 ←
 min
(
 part,win
)
5:
 maxV al
 ←
 max
(
 part,win
)
6:
 partition
 ←
 (
minV al
×
C 
2 +
 maxV al
×
C 
3) mod
 NUMPARTITIONS 
7:
 end if 
produce: (1) the result links for partitions that are small enough to be pro-cessed in a single node, and (2) intermediate data for partitions that requirefurther processing. The main routine sets up each base partition MapReduce job to use
 Map base
 and
 Reduce base
 as the
 map
 and
 reduce
 functions, respec-tively. Additionally, the default
 partition
 function is replaced by
 Partition base
and the default
 sortCompare
 and
 groupCompare
 functions are replaced by
Compare base
. This section explains in detail each of these functions.
Map base
, the map function for the base partition rounds, is presented inAlgorithm 2. The format of the input key-value pairs, i.e.,
 k
1
,v
1, is:
 k
1 =
id,v
1 = (
id,elem
), and the format of the intermediate key-value pairs, i.e.,
k
2
,v
2, is:
 k
2 = (
 part,win
)
,v
2 = (
id,elem,part
). We use the value -1 whena given parameter is not applicable or will not be needed in the future. TheMapReduce framework divides the job input data into chunks and creates
 map
tasks in multiple nodes to process them. Each
 map
 task is called multiple timesand each call executes the
 Map base
 function for a given record (
id,
(
id,elem
))of the input data. The
 Map base
 function identiﬁes the closest pivot
 p
 to
 elem
(line 1). The function then outputs one intermediate key-value pair of theform ((
 p,
−
1)
,
(
id,elem,
−
1)) for the base partition that
 elem
 belongs to (line2) and one key-value pair of the form ((
 p,i
)
,
(
id,elem,p
)) for each window-pairpartition (corresponding to pivots
 p
 and
 i
) that
 elem
 belongs to (lines 3 to 9).Fig. 5 shows an example of the intermediate key-value pairs generated by
Map base
. Region
 T 
 contains all the key-value pairs of the job input data.Diﬀerent segments of this region are processed by diﬀerent
 map
 tasks on possiblydiﬀerent nodes. The overall result of the
 map
 phase is independent of thenumber or distribution of the
 map
 tasks. In this example, they will alwaysgenerate the key-value pairs shown in partitions
 P 
0,
 P 
1 and
 P 
0
 P 
1. Each inputrecord generates an intermediate key-value pair corresponding to its associatedbase partition (
P 
0 or
 P 
1). Additionally, each record in the windows between thetwo base partitions, e.g.,
 id
5
 and
 id
6
, generates a key-value pair correspondingto the window-pair partition
 P 
0
 P 
1.The MapReduce framework partitions the intermediate data generated by
map
 tasks. This partitioning is performed calling the
 Partition base 
 functionpresented in Algorithm 3.
 Partition base 
 receives an intermediate key, i.e.,
 k
2 =11

